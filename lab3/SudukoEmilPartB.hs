import Data.List
import Data.List.Split
import Data.Maybe
import Prelude
import Data.Char
import Test.QuickCheck
import Debug.Trace

data Sudoku = Sudoku { rows :: [[Maybe Int]] }
  deriving(Show, Eq)


-- creates a blank suduko. firsts creates a list with 9 "Nothing", and then
-- a list with 9 lists containing "Nothing", which results in a 9x9 blank suduko
allBlankSudoku :: Sudoku
allBlankSudoku = Sudoku (replicate 9 (replicate 9 Nothing))

-- Checks wheather a sudoku is of correct size. first check if there are 9
-- rows, and then check so that all rows contains 9 elements (9 columns) with
-- isSudoku columns
isSudoku :: Sudoku -> Bool
isSudoku (Sudoku rows) = length rows == 9 && isSudokuColumns rows

-- has a suduko table ([[Maybe Int]]) as input, and it cheks so that all
-- rows has the lenght 9
isSudokuColumns :: [[Maybe Int]] -> Bool
isSudokuColumns [] = True
isSudokuColumns (x:xs) = length x == 9 && isCorrectValue x && isSudokuColumns xs

--checks that every value in a row is between 1 - 9 or nothing
isCorrectValue :: [Maybe Int] -> Bool
isCorrectValue [] = True
isCorrectValue (Nothing:xs) = isCorrectValue xs
isCorrectValue ((Just x):xs) | x > 0 && x < 10 = isCorrectValue xs
                             | otherwise = False

-- checks weather the sudoku is "solved" or not. a sudoku is solved if its a
-- sudoku and no cell contains "Nothing" (uses isRowsSolved to determine if the
-- sudoku contains "Nothing").
isSolved :: Sudoku -> Bool
isSolved (Sudoku a) = isSudoku (Sudoku a) && isRowsSolved a

-- checks wheather the board contains the element "Nothing" or not. Returns
-- true if not contains, otherwise false
isRowsSolved :: [[Maybe Int]] -> Bool
isRowsSolved [] = True
isRowsSolved (x:xs) | Nothing `elem` x = False
                    | otherwise = isRowsSolved xs

-- method used to print a sudoku. uses a helpfunction rowString to create
-- strings of each row. the rows are then concatinaded and then prints.
printSudoku :: Sudoku -> IO ()
printSudoku (Sudoku l) = do let s = concatMap rowString l
                            putStrLn s

-- creates a string that represents a row.
rowString:: [Maybe Int] -> String
rowString [] = "\n"
rowString (Nothing:xs) = "." ++ rowString xs
rowString (Just n:xs) = show n ++ rowString xs

-- reads suduko from a file. uses a helpfunction readRow to create a
-- [Maybe Int] from a row in the file.
readSudoku :: FilePath -> IO Sudoku
readSudoku f = do file <- readFile f
                  let sudoku = Sudoku (map readRow (lines file))
                  return sudoku

-- used in readSudoku. used to read a row and return it as a [Maybe Int]
readRow::String -> [Maybe Int]
readRow [] = []
readRow (x:xs) | isDigit x = Just (digitToInt x) : readRow xs
               | otherwise = Nothing : readRow xs

-- creates a arbitrary cell. frequency is used so that we can determine the
-- probability for a cell with "Nothing" or a digit. we uses 9 on "Nothing" and 1
-- on "Just n" since the assignment said 90% vs 10%
cell :: Gen (Maybe Int)
cell = frequency [(9, return Nothing ),
                  (1, elements [Just n | n <- [1..9]])]

-- Given in the assignment. An abitrary Sudoku
instance Arbitrary Sudoku where
  arbitrary =
    do rows <- sequence [ sequence [ cell | j <- [1..9] ] | i <- [1..9] ]
       return (Sudoku rows)

-- checks so that the sudokus generated by the Arbitary Sudoku is correct
prop_Sudoku :: Sudoku -> Bool
prop_Sudoku = isSudoku


type Block = [Maybe Int]

-- checks so that a block don't contains more than one of the same value
isOkayBlock :: Block -> Bool
isOkayBlock [] = True
isOkayBlock (x:xs) | x `elem` xs && x /= Nothing = False
                   | otherwise = isOkayBlock xs

-- creates a list of all blocks in the suduko. first all the rows, then all the
-- columns (transpose the list) and then all the 3x3 blocks (uses helpfuntion
-- get3x3Block)
blocks :: Sudoku -> [Block]
blocks (Sudoku l) = l ++ transpose l ++ get3x3Block l

-- returns all 3x3 blocks in the sudoku. It first gets the 3x3 boxes generated
-- by the first 3 rows. Then it moves to the next three rows, and finaly the last
-- 3 rows
--       1     |     2     |     3           <-- the splitup
-- -------------------------------------
-- | * | * | * | * | * | * | * | * | * |     <-- x
-- -------------------------------------
-- | * | * | * | * | * | * | * | * | * |     <-- y
-- -------------------------------------
-- | * | * | * | * | * | * | * | * | * |     <-- z
-- -------------------------------------
-- ..          |           |
-- ..
get3x3Block :: [[Maybe Int]] -> [Block]
get3x3Block [] = []
get3x3Block (x:y:z:xs) = (x1 ++ y1 ++ z1): (x2 ++ y2 ++ z2) : (x3 ++ y3 ++ z3) : get3x3Block xs
  where [x1,x2,x3] = chunksOf 3 x
        [y1,y2,y3] = chunksOf 3 y
        [z1,z2,z3] = chunksOf 3 z


-- function checks so that the sudoku isSudoku and so that non of the blocks
-- contains more than one of each element
isOkay :: Sudoku -> Bool
isOkay sud = isSudoku sud && allBlocksOk (blocks sud)

-- method used to check so that non of the blocks in the list contains more than
-- one of each elemet
allBlocksOk :: [Block] -> Bool
allBlocksOk [] = True
allBlocksOk (x:xs) = isOkayBlock x && allBlocksOk xs



-- Type for the position in the sudoku
type Pos = (Int,Int)


rPos :: Gen Pos
rPos = elements [(x,y)| x <- [0..8], y <- [0..8]]


-- Given a sudoku this functions finds the blank cells and returns a list of the
-- positions. Using getBlankRow
blanks :: Sudoku -> [Pos]
blanks (Sudoku l) = getBlankRow 0 l

-- Used to find the rows that contains blank cells. The input is an integer and
-- a [[Maybe Int]]. The integer is the row number. The function is using getBlankElem
-- to get the column position.
getBlankRow :: Int -> [[Maybe Int]] -> [Pos]
getBlankRow _ [] = []
getBlankRow n (x:xs) = [(n,y) | y <- getBlankElem 0 x ] ++ getBlankRow (n+1) xs

-- function that checks what position in a row a blank cell has. The input is
-- integer, which represent the position and a [Maybe Int] that is the row
-- the function goes through
getBlankElem :: Int -> [Maybe Int] -> [Int]
getBlankElem _ [] = []
getBlankElem c (Nothing:xs) = c : getBlankElem (c+1) xs
getBlankElem c (x:xs) = getBlankElem (c+1) xs

-- checks wheater the positions in the outpus is blank positions in the sudoku
isBlank :: Sudoku -> [Pos] -> Bool
isBlank _ [] = True
isBlank (Sudoku l) (x:xs) = isNothing ((l !! row) !! column)
                            && isBlank (Sudoku l) xs
  where (row,column) = x

-- Property that checks the blanks method works as it should
prop_blank :: Sudoku -> Bool
prop_blank sud = isBlank sud (blanks sud)

-- Given a  list, and a touple of position and value. This function changes the
-- value of the element on the given position in the list to the value given in
--the touple
(!!=) :: [a] -> (Int,a) -> [a]
(!!=) [] _ = []
(!!=) x (pos,_) | length x < pos = error "(!!=): index to big"
                | pos < 0        = error "(!!=): pos can't be negative"
(!!=) x (pos,val) = take pos x ++ [val] ++ drop (pos + 1) x

------------------------------------------------
-- TODO fungerar ej
------------------------------------------------
prop_addElement :: Eq a => [a] -> (Int, a) -> Bool
prop_addElement a (pos, val) = val == (b !! pos)
  where b = a !!= (pos, val)

-- TODO (Use Eriks!)
-- Updates a value in a suduko at a given position and then return the updated
-- suduko
update :: Sudoku -> Pos -> Maybe Int -> Sudoku
update (Sudoku l) pos n = Sudoku (update' l pos n)

update' :: [[Maybe Int]] -> Pos -> Maybe Int -> [[Maybe Int]]
update' (x:xs) (0,col) n = x !!= (col, n) : xs
update' (x:xs) (row,col) n = x : update' xs (row-1, col) n




---------------------------------------------------------------
--TODO Property for update. Check so that it has been updated--
---------------------------------------------------------------

getPosValue :: Sudoku -> Pos -> Maybe Int
getPosValue (Sudoku l) (row,col) = ( l !! row) !! col

prop_updateSudoku :: Sudoku -> Pos -> Maybe Int -> Bool
prop_updateSudoku sud pos val = getPosValue updatedSud pos == val
  where updatedSud = update sud pos val

candidates :: Sudoku -> Pos -> [Int]
candidates = candidates' 9

candidates' :: Int -> Sudoku -> Pos -> [Int]
candidates' 0 _ _ = []
candidates' n sud pos |Â isOkay (update sud pos (Just n)) = n : candidates' (n-1) sud pos
                      | otherwise = candidates' (n-1) sud pos



solve :: Sudoku -> Maybe Sudoku
solve sud | not (isOkay sud) = Nothing
solve sud = solve' sud (blanks sud)

solve' :: Sudoku -> [Pos] -> Maybe Sudoku
solve' sud [] = Just sud
solve' sud (x:xs) = tryCandidate sud x can
  where can = candidates sud x


tryCandidate :: Sudoku -> Pos -> [Int] -> Maybe Sudoku
tryCandidate _ _ [] = Nothing
tryCandidate sud pos (x:xs) | isNothing solveNext = tryCandidate sud pos xs
                            | otherwise = solveNext
  where updated = update sud pos (Just x)
        solveNext = solve updated

readAndSolve :: FilePath -> IO ()
readAndSolve file = do s <- readSudoku file
                       let sud = solve s
                       case sud of Nothing -> putStrLn "empty suduko"
                                   _       -> printSudoku (fromJust sud)


isSolutionOf :: Sudoku -> Sudoku -> Bool
isSolutionOf sud1 sud2 = sud1 == fromJust (solve sud2)

example :: Sudoku
example =
  Sudoku
    [ [Just 3, Just 6, Nothing,Nothing,Just 7, Just 1, Just 2, Nothing,Nothing]
    , [Nothing,Just 5, Nothing,Nothing,Nothing,Nothing,Just 1, Just 8, Nothing]
    , [Nothing,Nothing,Just 9, Just 2, Nothing,Just 4, Just 7, Nothing,Nothing]
    , [Nothing,Nothing,Nothing,Nothing,Just 1, Just 3, Nothing,Just 2, Just 8]
    , [Just 4, Nothing,Nothing,Just 5, Nothing,Just 2, Nothing,Nothing,Just 9]
    , [Just 2, Just 7, Nothing,Just 4, Just 6, Nothing,Nothing,Nothing,Nothing]
    , [Nothing,Nothing,Just 5, Just 3, Nothing,Just 8, Just 9, Nothing,Nothing]
    , [Nothing,Just 8, Just 3, Nothing,Nothing,Nothing,Nothing,Just 6, Nothing]
    , [Nothing,Nothing,Just 7, Just 6, Just 9, Nothing,Nothing,Just 4, Just 3]
    ]

testl2 :: [Int]
testl2 = [1,2,4,5,6,7]

testl :: [Maybe Int]
testl = [Just 3, Just 6, Nothing,Nothing,Just 7, Just 1, Just 2, Nothing,Nothing]


test::[[Maybe Int]]
test = [ [Just 3, Just 6, Nothing,Nothing,Just 7, Just 1, Just 2, Nothing,Nothing]
       , [Nothing,Just 5, Nothing,Nothing,Nothing,Nothing,Just 1, Just 8, Nothing]
       , [Nothing,Nothing,Just 9, Just 2, Nothing,Just 4, Just 7, Nothing,Nothing]
       , [Nothing,Nothing,Nothing,Nothing,Just 1, Just 3, Nothing,Just 2, Just 8]
       , [Just 4, Nothing,Nothing,Just 5, Nothing,Just 2, Nothing,Nothing,Just 9]
       , [Just 2, Just 7, Nothing,Just 4, Just 6, Nothing,Nothing,Nothing,Nothing]
       , [Nothing,Nothing,Just 5, Just 3, Nothing,Just 8, Just 9, Nothing,Nothing]
       , [Nothing,Just 8, Just 3, Nothing,Nothing,Nothing,Nothing,Just 6, Nothing]
       , [Nothing,Nothing,Just 7, Just 6, Just 9, Nothing,Nothing,Just 4, Just 3]
       ]
